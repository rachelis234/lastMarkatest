import { DataSource } from '@angular/cdk/collections';
import { BehaviorSubject, Subject, Observable } from 'rxjs';
import { ValidatorService } from './validator.service';
import { TableElement } from './table-element';
export declare class TableDataSource<T> extends DataSource<TableElement<T>> {
    private validatorService;
    private config;
    protected rowsSubject: BehaviorSubject<TableElement<T>[]>;
    datasourceSubject: Subject<T[]>;
    protected dataConstructor: new () => T;
    protected dataKeys: any[];
    protected currentData: any;
    /**
     * Creates a new TableDataSource instance, that can be used as datasource of `@angular/cdk` data-table.
     * @param data Array containing the initial values for the TableDataSource. If not specified, then `dataType` must be specified.
     * @param dataType Type of data contained by the Table. If not specified, then `data` with at least one element must be specified.
     * @param validatorService Service that create instances of the FormGroup used to validate row fields.
     * @param config Additional configuration for table.
     */
    constructor(data: T[], dataType?: new () => T, validatorService?: ValidatorService, config?: {
        prependNewElements: boolean;
        suppressErrors: boolean;
    });
    protected checkValidatorFields(validatorService: ValidatorService): void;
    protected logError(message: string): void;
    /**
     * Start the creation of a new element, pushing an empty-data row in the table.
     */
    createNew(): void;
    /**
     * Confirm creation of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm creation neither disable editing.
     * @param row Row to be confirmed.
     */
    confirmCreate(row: TableElement<T>): boolean;
    /**
     * Confirm edition of the row. Save changes and disable editing.
     * If validation active and row data is invalid, it doesn't confirm editing neither disable editing.
     * @param row Row to be edited.
     */
    confirmEdit(row: TableElement<T>): boolean;
    /**
     * Delete the row with the index specified.
     */
    delete(id: number): void;
    /**
   * Get row from the table.
   * @param id Id of the row to retrieve, -1 returns the current new line.
   */
    getRow(id: number): TableElement<T>;
    /**
     * Update the datasource with a new array of data. If the array reference
     * is the same as the previous one, it doesn't trigger an update.
     * @param data Data to update the table datasource.
     * @param options Specify options to update the datasource.
     * If emitEvent is true and the datasource is updated, it emits an event
     * from 'datasourceSubject' with the updated data. If false, it doesn't
     * emit an event. True by default.
     */
    updateDatasource(data: T[], options?: {
        emitEvent: boolean;
    }): void;
    /**
     * Checks the existance of the a new row (not yet saved).
     * @param source
     */
    protected existsNewElement(source: TableElement<T>[]): boolean;
    /**
     * Returns the possible index of the new row depending on the insertion type.
     * It doesn't imply that the new row is created, that must be checked.
     * @param source
     */
    protected getNewRowIndex(source: any): number;
    /**
     * Returns the row id from the index specified. It does
     * not consider if the new row is present or not, assumes
     * that new row is not present.
     * @param index Index of the array.
     * @param count Quantity of elements in the array.
     */
    protected getRowIdFromIndex(index: number, count: number): number;
    /**
     * Returns the index from the row id specified.
     * It takes into account if the new row exists or not.
     * @param id
     * @param source
     */
    protected getIndexFromRowId(id: number, source: TableElement<T>[]): number;
    /**
     * Update rows ids in the array specified, starting in the specified index
     * until the start/end of the array, depending on config.prependNewElements
     * configuration.
     * @param initialIndex Initial index of source to be updated.
     * @param source Array that contains the rows to be updated.
     */
    protected updateRowIds(initialIndex: number, source: TableElement<T>[]): void;
    /**
     * Get the data from the rows.
     * @param rows Rows to extract the data.
     */
    protected getDataFromRows(rows: TableElement<T>[]): T[];
    /**
     * Update the datasource with the data contained in the specified rows.
     * @param rows Rows that contains the datasource's new data.
     */
    protected updateDatasourceFromRows(rows: TableElement<T>[]): void;
    /**
     * From an array of data, it returns rows containing the original data.
     * @param arrayData Data from which create the rows.
     */
    protected getRowsFromData(arrayData: T[]): TableElement<T>[];
    /**
     * Create a new object with identical structure than the table source data.
     * It uses the object's type contructor if available, otherwise it creates
     * an object with the same keys of the first element contained in the original
     * datasource (used in the constructor).
     */
    protected createNewObject(): T;
    /** Connect function called by the table to retrieve one stream containing
     *  the data to render. */
    connect(): Observable<TableElement<T>[]>;
    disconnect(): void;
}
